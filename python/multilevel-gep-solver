#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# Copyright 2016 Christoph Conrads
#
# This file is part of DCGeig and it is subject to the terms of the DCGeig
# license. See http://DCGeig.tech/license for a copy of this license.

import numpy as NP

import scipy.sparse as SS
import scipy.sparse.linalg as LA

import scipy.io as IO

import dcgeig
import dcgeig.error_analysis as EA
import dcgeig.multilevel_solver as MS
import dcgeig.multilevel_tools as multilevel_tools
import dcgeig.sparse_tools as sparse_tools
import dcgeig.utils as utils
from dcgeig.sparse_tools import Tree

import argparse

import copy

import sys
import os.path as OP

import time



def check_if_positive_integer(string):
    i = int(string)
    if (i <= 0):
        msg = '{0} is an invalid positive integer value'
        raise argparse.ArgumentTypeError(msg.format(string))

    return i



def check_if_positive_real(string):
    f = float(string)
    if (f <= 0) or NP.isnan(f) or NP.isinf(f):
        msg = '{0} is an invalid positive real value'
        raise argparse.ArgumentTypeError(msg.format(string))

    return f



def check_if_nonnegative_real(string):
    f = float(string)
    if (f < 0) or NP.isnan(f) or NP.isinf(f):
        msg = '{0} is an invalid non-negative real value'
        raise argparse.ArgumentTypeError(msg.format(string))

    return f



def make_argument_parser(default_options):
    description = \
        'A multilevel eigensolver for large, sparse generalized eigenvalue \
         problems with real symmetric positive semidefinite matrices.'

    parser = argparse.ArgumentParser(description=description)
    parser.add_argument(
        '--version',
        action='version',
        version='%(prog)s {0}'.format(dcgeig.__version__))

    parser.add_argument(
        'file',
        type=str,
        help='path to the file containing the stiffness matrix in Matrix Market format')

    parser.add_argument(
        'cutoff',
        type=check_if_positive_real,
        help='the largest desired eigenvalue')


    parser.add_argument(
        '--max-dim-direct-solve',
        metavar='n_direct',
        default=default_options.n_direct,
        type=check_if_positive_integer,
        help='maximum dimension for direct GEP solves')

    parser.add_argument(
        '--tolerance',
        metavar='tol',
        default=default_options.tol,
        type=check_if_positive_real,
        help='maximum tolerance such that backward error <= tol')


    parser.add_argument(
        '--stats',
        metavar='stat_file',
        type=str,
        help='save solver statistics in stat_file')

    parser.add_argument(
        '-q', '--quiet',
        action='store_true',
        help='only print one line of solution information')

    return parser



def normalize_path(filename):
    assert isinstance(filename, str)

    path = OP.expanduser(filename)
    abs_path = path if OP.isabs(path) else OP.abspath(path)

    return abs_path



def sanitize_matrix_pencil(K, M):
    if not utils.is_hermitian(K):
        raise ValueError('K must be Hermitian')
    if not SS.isspmatrix(K):
        raise ValueError('K must be sparse')

    if not utils.is_hermitian(M):
        raise ValueError('M must be Hermitian')
    if not SS.isspmatrix(M):
        raise ValueError('K must be sparse')

    if K.shape[0] != M.shape[0]:
        raise ValueError('Matrices must have the same dimension')

    return K, M



def sanitize_input(default_options, user_options):
    # add missing options
    options = copy.copy(default_options)

    options.k_path = normalize_path( user_options['file'] )
    options.lambda_c = user_options['cutoff']

    options.n_direct = user_options['max_dim_direct_solve']
    options.tol = user_options['tolerance']

    options.stats_path = \
        normalize_path(user_options['stats']) if user_options['stats'] else None

    options.be_quiet = user_options['quiet']


    # tolerance
    if options.tol >= 1:
        raise ValueError('The tolerance must be between 0 and 1')


    # get stiffness matrix
    k_path = options.k_path
    K = IO.mmread(k_path)


    # get mass matrix
    M = SS.identity(K.shape[0], dtype=K.dtype)
    options.m_path = None

    k_dirname = OP.dirname(k_path)
    k_basename = OP.basename(k_path)
    assert k_basename != ''

    if str.count(k_basename, 'k') == 1:
        m_basename = str.replace(k_basename, 'k', 'm')
        m_path = OP.join(k_dirname, m_basename)

        try:
            M = IO.mmread(m_path)
            options.m_path = m_path
        except IOError as e:
            if e.errno != 2:
                raise


    # open stat file
    if options.stats_path:
        line_buffering = 1
        stats_file = open(options.stats_path, 'w', line_buffering)
    else:
        stats_file = None


    A, B = sanitize_matrix_pencil(K, M)

    return A, B, stats_file, options



def print_input_information(options, K, M):
    if options.be_quiet:
        return


    fmt = ( \
        '{:16s} {:s}\n'
        '{:16s} {:s}\n'
        '{:16s} {:d}\n'
        '{:16s} {:.2e}\n'
        '{:16s} {:.2e}\n'
    )

    m_path = options.m_path

    text = fmt.format( \
        'Stiffness matrix', options.k_path,
        'Mass matrix', m_path if m_path else 'identity',
        'n', K.shape[0],
        'lambda_c', options.lambda_c,
        'tol', options.tol
    )

    print text



def print_output_information( \
        options, n, s, d_s, eta, delta, wallclock_time, cpu_time):
    d = s * d_s
    lambda_c = options.lambda_c
    t = d <= lambda_c
    n_c = NP.sum(t)
    rfe = delta / abs(d_s)


    if options.be_quiet:
        t[0] = True

        # filename with 18 chars: crankseg_1.mtx.bz2
        fmt = '{:18s} {:8.2e} {:6d} {:4d} {:8.2e} {:8.2e} {:7.1f} {:8.1f}'

        k_file = OP.basename(options.k_path)
        text = fmt.format( \
            k_file, lambda_c, n, n_c, max(eta[t]), max(rfe[t]),
            wallclock_time, cpu_time)

        print text

        return


    solver_info_fmt = 'Solver completed in {:.1f} seconds ({:.1f}s CPU time).'
    print solver_info_fmt.format(wallclock_time, cpu_time)

    if n_c == 0:
        fmt = ( \
            'The solver found {:} eigenpairs with '
            'no eigenvalues below the cutoff.\n'
            'The smallest eigenvalue is {:.2e}.')
        print fmt.format(d.size, min(d))
        return


    fmt = ( \
        'Number of eigenpairs: {}\n'
        '{:23s}  {:8s}  {:8s}   {:8s}  {:8s}\n'
        '{:23s}  {:.2e}  {:.2e}   {:.2e}  {:.2e}\n'
        '{:23s}  {:.2e}  {:.2e}   {:.2e}  {:.2e}\n'
        '{:23s}  {:.2e}  {:.2e}   {:.2e}  {:.2e}'
    )

    text = fmt.format( \
        NP.sum(t),
        '', 'min', 'max', 'mean', 'median',
        'Eigenvalues',
        NP.min(d[t]), NP.max(d[t]), NP.mean(d[t]), NP.median(d[t]),
        'Relative backward error',
        NP.min(eta[t]), NP.max(eta[t]), NP.mean(eta[t]), NP.median(eta[t]),
        'Relative forward error',
        NP.min(rfe[t]), NP.max(rfe[t]), NP.mean(rfe[t]), NP.median(rfe[t]),
    )

    print text



def get_stats_file_header(options):
    fmt = ( \
        '# multilevel_gep_solve {:}\n'
        '# {:18s} {:s}\n'
        '# {:18s} {:s}\n'
        '# {:18s} {:e}\n'
        '# {:18s} {:d}\n'
        '# {:18s} {:e}\n'
        '# {:18s} {:d}\n'
        '# {:18s} {:d}\n'
        '# {:18s} {:d}\n')

    settings = fmt.format( \
        dcgeig.__version__,
        'stiffness_matrix', options.k_path,
        'mass_matrix', options.m_path if options.m_path else 'identity',
        'lambda_c', options.lambda_c,
        'n_direct', options.n_direct,
        'tol', options.tol,
        'c_s', options.c_s,
        'n_s_min', options.n_s_min,
        'max_num_iterations', options.max_num_iterations)

    return settings + '#' + multilevel_tools.get_stats_header()



def main():
    # scan input
    default_options = multilevel_tools.get_default_options()
    argument_parser = make_argument_parser(default_options)
    namespace = argument_parser.parse_args()

    K, M, stats_file, input_options = \
        sanitize_input(default_options, vars(namespace))
    n = K.shape[0]

    options = copy.copy(input_options)

    # save stats?
    if stats_file:
        def show_stats(message):
            assert isinstance(message, str)
            stats_file.write(message)

        show_stats( get_stats_file_header(options) )
        options.show_stats = show_stats


    print_input_information(input_options, K, M)


    # balance matrix pencil
    s, D = sparse_tools.balance_matrix_pencil(K, M)
    K = D*K*D
    M = D*(s*M)*D

    options.lambda_c = input_options.lambda_c / s
    options.s = s

    options.K = SS.csc_matrix(K)
    options.M = SS.csc_matrix(M)

    # manual memory management
    n = K.shape[0]
    K = None; M = None

    # start solving
    wallclock_time_start = time.time()
    cpu_time_start = time.clock()

    d, eta, delta = MS.execute(options)

    wallclock_time_end = time.time()
    cpu_time_end = time.clock()


    # print results
    wallclock_time = wallclock_time_end - wallclock_time_start
    cpu_time = cpu_time_end - cpu_time_start

    print_output_information( \
        input_options, n, s, d, eta, delta,
        wallclock_time, cpu_time)

    # clean up
    if stats_file:
        stats_file.close()



if __name__ == '__main__':
    sys.exit( main() )
