#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# Copyright 2016 Christoph Conrads
#
# This file is part of DCGeig and it is subject to the terms of the DCGeig
# license. See http://DCGeig.tech/license for a copy of this license.

import numpy as NP

import scipy.sparse as SS
import scipy.sparse.linalg as LA

import scipy.io as IO

import dcgeig
import dcgeig.error_analysis as EA
import dcgeig.multilevel_solver as MS
import dcgeig.multilevel_tools as multilevel_tools
import dcgeig.sparse_tools as sparse_tools
import dcgeig.utils as utils
from dcgeig.sparse_tools import Tree

import argparse

import copy

import sys
import os.path as OP

import time



def check_if_positive_integer(string):
    i = int(string)
    if (i <= 0):
        msg = '{0} is an invalid positive integer value'
        raise argparse.ArgumentTypeError(msg.format(string))

    return i



def check_if_positive_real(string):
    f = float(string)
    if (f <= 0) or NP.isnan(f) or NP.isinf(f):
        msg = '{0} is an invalid positive real value'
        raise argparse.ArgumentTypeError(msg.format(string))

    return f



def check_if_nonnegative_real(string):
    f = float(string)
    if (f < 0) or NP.isnan(f) or NP.isinf(f):
        msg = '{0} is an invalid non-negative real value'
        raise argparse.ArgumentTypeError(msg.format(string))

    return f



def make_argument_parser(default_options):
    description = \
        'A multilevel eigensolver for large, sparse generalized eigenvalue \
         problems with real symmetric positive semidefinite matrices.'

    parser = argparse.ArgumentParser(description=description)
    parser.add_argument(
        '--version',
        action='version',
        version='%(prog)s {0}'.format(dcgeig.__version__))

    parser.add_argument(
        'file',
        type=str,
        help='path to the file containing the stiffness matrix in Matrix Market format')

    parser.add_argument(
        'cutoff',
        type=check_if_positive_real,
        help='the largest desired eigenvalue')


    parser.add_argument(
        '--max-dim-direct-solve',
        metavar='n_direct',
        default=default_options.n_direct,
        type=check_if_positive_integer,
        help='maximum dimension for direct GEP solves')

    parser.add_argument(
        '--tolerance',
        metavar='tol',
        default=NP.finfo(NP.float32).eps,
        type=check_if_positive_real,
        help='maximum tolerance such that backward error <= tol')


    parser.add_argument(
        '--stats',
        metavar='stat_file',
        type=str,
        help='save solver statistics in stat_file')

    parser.add_argument(
        '-q', '--quiet',
        action='store_true',
        help='only print one line of solution information')

    return parser



def normalize_path(filename):
    assert isinstance(filename, str)

    path = OP.expanduser(filename)
    abs_path = path if OP.isabs(path) else OP.abspath(path)

    return abs_path



def sanitize_matrix_pencil(K, M):
    if not utils.is_hermitian(K):
        raise ValueError('K must be Hermitian')
    if not SS.isspmatrix(K):
        raise ValueError('K must be sparse')

    if not utils.is_hermitian(M):
        raise ValueError('M must be Hermitian')
    if not SS.isspmatrix(M):
        raise ValueError('K must be sparse')

    if K.shape[0] != M.shape[0]:
        raise ValueError('Matrices must have the same dimension')

    A = SS.csc_matrix(K)
    B = SS.csc_matrix(M)

    return A, B



def sanitize_input(default_options, user_options):
    # add missing options
    options = copy.copy(default_options)

    options.k_path = normalize_path( user_options['file'] )
    lambda_c = user_options['cutoff']

    options.n_direct = user_options['max_dim_direct_solve']
    tol = user_options['tolerance']

    options.stats_path = \
        normalize_path(user_options['stats']) if user_options['stats'] else None

    options.be_quiet = user_options['quiet']


    # tolerance
    if tol >= 1:
        raise ValueError('The tolerance must be between 0 and 1')


    # get stiffness matrix
    k_path = options.k_path
    K = IO.mmread(k_path)


    # get mass matrix
    M = SS.identity(K.shape[0], dtype=K.dtype)
    options.m_path = None

    k_dirname = OP.dirname(k_path)
    k_basename = OP.basename(k_path)
    assert k_basename != ''

    if str.count(k_basename, 'k') == 1:
        m_basename = str.replace(k_basename, 'k', 'm')
        m_path = OP.join(k_dirname, m_basename)

        try:
            M = IO.mmread(m_path).astype(K.dtype)
            options.m_path = m_path
        except IOError as e:
            if e.errno != 2:
                raise

    assert K.dtype == M.dtype


    A, B = sanitize_matrix_pencil(K, M)

    return options, A, B, lambda_c, tol



def print_input_information(options, K, M, lambda_c, tol):
    if options.be_quiet:
        return


    fmt = ( \
        '{:16s} {:s}\n'
        '{:16s} {:s}\n'
        '{:16s} {:d}\n'
        '{:16s} {:.2e}\n'
        '{:16s} {:.2e}\n'
    )

    m_path = options.m_path

    text = fmt.format( \
        'Stiffness matrix', options.k_path,
        'Mass matrix', m_path if m_path else 'identity',
        'n', K.shape[0],
        'lambda_c', lambda_c,
        'tol', tol
    )

    print text



def print_output_information( \
        options, lambda_c, tol, d, X, eta, kappa, wallclock_time, cpu_time):
    n = X.shape[0]
    t = d <= lambda_c
    n_c = NP.sum(t)
    delta = eta * kappa
    rfe = delta / abs(d)


    if options.be_quiet:
        t[0] = True

        # filename with 18 chars: crankseg_1.mtx.bz2
        fmt = '{:18s} {:8.2e} {:6d} {:4d} {:8.2e} {:8.2e} {:7.1f} {:8.1f}'

        k_file = OP.basename(options.k_path)
        text = fmt.format( \
            k_file, lambda_c, n, n_c, max(eta[t]), max(rfe[t]),
            wallclock_time, cpu_time)

        print text

        return


    solver_info_fmt = 'Solved in {:.1f} seconds ({:.1f}s CPU time).'
    print solver_info_fmt.format(wallclock_time, cpu_time)

    if n_c == 0:
        fmt = ( \
            'The solver found {:} eigenpairs with '
            'no eigenvalues below the cutoff.\n'
            'The smallest eigenvalue is {:.2e}.')
        print fmt.format(d.size, min(d))
        return


    fmt = ( \
        'Number of eigenpairs: {}\n'
        '{:23s}  {:8s}  {:8s}   {:8s}  {:8s}\n'
        '{:23s}  {:.2e}  {:.2e}   {:.2e}  {:.2e}\n'
        '{:23s}  {:.2e}  {:.2e}   {:.2e}  {:.2e}\n'
        '{:23s}  {:.2e}  {:.2e}   {:.2e}  {:.2e}'
    )

    text = fmt.format( \
        NP.sum(t),
        '', 'min', 'max', 'mean', 'median',
        'Eigenvalues',
        NP.min(d[t]), NP.max(d[t]), NP.mean(d[t]), NP.median(d[t]),
        'Relative backward error',
        NP.min(eta[t]), NP.max(eta[t]), NP.mean(eta[t]), NP.median(eta[t]),
        'Relative forward error',
        NP.min(rfe[t]), NP.max(rfe[t]), NP.mean(rfe[t]), NP.median(rfe[t]),
    )

    print text



def get_stats_file_header(options, lambda_c, tol):
    fmt = ( \
        '# multilevel_gep_solve {:}\n'
        '# {:18s} {:s}\n'
        '# {:18s} {:s}\n'
        '# {:18s} {:e}\n'
        '# {:18s} {:d}\n'
        '# {:18s} {:e}\n'
        '# {:18s} {:d}\n'
        '# {:18s} {:d}\n'
        '# {:18s} {:d}\n')

    settings = fmt.format( \
        dcgeig.__version__,
        'stiffness_matrix', options.k_path,
        'mass_matrix', options.m_path if options.m_path else 'identity',
        'lambda_c', lambda_c,
        'n_direct', options.n_direct,
        'tol', tol,
        'c_s', options.c_s,
        'n_s_min', options.n_s_min,
        'max_num_iterations', options.max_num_iterations)

    return settings



def main():
    # scan input
    default_options = multilevel_tools.get_default_options()
    argument_parser = make_argument_parser(default_options)
    namespace = argument_parser.parse_args()

    options, A, B, lambda_c, tol = \
        sanitize_input(default_options, vars(namespace))
    n = A.shape[0]


    print_input_information(options, A, B, lambda_c, tol)


    # normalize stiffness matrix norm for easier debugging and stats reading
    I = SS.identity(n, format='csc', dtype=A.dtype)
    s, _ = sparse_tools.balance_matrix_pencil(I / LA.norm(I), A)

    K = s*A
    M = s*B

    del s
    del I


    # start solving
    wallclock_time_start = time.time()
    cpu_time_start = time.clock()

    d, X, stats = MS.execute(options, K, M, lambda_c, tol)
    eta = EA.compute_backward_error(K, M, d, X)
    kappa = EA.compute_condition_number(K, M, d, X)

    wallclock_time_end = time.time()
    cpu_time_end = time.clock()


    # print results
    wallclock_time = wallclock_time_end - wallclock_time_start
    cpu_time = cpu_time_end - cpu_time_start

    print_output_information( \
        options, lambda_c, tol, d, X, eta, kappa,
        wallclock_time, cpu_time)


    # print stats?
    if options.stats_path:
        use_line_buffering = 1
        stats_file = open(options.stats_path, 'w', use_line_buffering)

        stats_file.write( get_stats_file_header(options, lambda_c, tol) )

        stats_file.close()



if __name__ == '__main__':
    sys.exit( main() )
